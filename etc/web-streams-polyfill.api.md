## API Report File for "web-streams-polyfill"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

// @public
export interface AbortSignal {
    readonly aborted: boolean;
    addEventListener(type: 'abort', listener: () => void): void;
    removeEventListener(type: 'abort', listener: () => void): void;
}

// @public
export class ByteLengthQueuingStrategy implements QueuingStrategy<ArrayBufferView> {
    constructor({ highWaterMark }: {
        highWaterMark: number;
    });
    // (undocumented)
    readonly highWaterMark: number;
    size(chunk: ArrayBufferView): number;
}

// @public
export class CountQueuingStrategy implements QueuingStrategy<any> {
    constructor({ highWaterMark }: {
        highWaterMark: number;
    });
    // (undocumented)
    readonly highWaterMark: number;
    size(): 1;
}

// @public
export interface PipeOptions {
    preventAbort?: boolean;
    preventCancel?: boolean;
    preventClose?: boolean;
    signal?: AbortSignal;
}

// @public
export interface QueuingStrategy<T = any> {
    highWaterMark?: number;
    size?: QueuingStrategySizeCallback<T>;
}

// @public
export type QueuingStrategySizeCallback<T = any> = (chunk: T) => number;

// Warning: (ae-forgotten-export) The symbol "ReadableByteStreamController" needs to be exported by the entry point polyfill.d.ts
//
// @public (undocumented)
export type ReadableByteStreamController = ReadableByteStreamController_2;

// @public
export class ReadableStream<R = any> {
    [Symbol.asyncIterator]: (options?: {
        preventCancel?: boolean;
    }) => ReadableStreamAsyncIterator<R>;
    constructor(underlyingSource: UnderlyingByteSource, strategy?: {
        highWaterMark?: number;
        size?: undefined;
    });
    constructor(underlyingSource?: UnderlyingSource<R>, strategy?: QueuingStrategy<R>);
    cancel(reason: any): Promise<void>;
    getIterator({ preventCancel }?: {
        preventCancel?: boolean;
    }): ReadableStreamAsyncIterator<R>;
    // Warning: (ae-forgotten-export) The symbol "ReadableStreamBYOBReader" needs to be exported by the entry point polyfill.d.ts
    getReader({ mode }: {
        mode: 'byob';
    }): ReadableStreamBYOBReader_2;
    // Warning: (ae-forgotten-export) The symbol "ReadableStreamDefaultReader" needs to be exported by the entry point polyfill.d.ts
    //
    // (undocumented)
    getReader(): ReadableStreamDefaultReader_2<R>;
    get locked(): boolean;
    pipeThrough<T>({ writable, readable }: {
        writable: WritableStream<R>;
        readable: ReadableStream<T>;
    }, { preventClose, preventAbort, preventCancel, signal }?: PipeOptions): ReadableStream<T>;
    pipeTo(dest: WritableStream<R>, { preventClose, preventAbort, preventCancel, signal }?: PipeOptions): Promise<void>;
    tee(): [ReadableStream<R>, ReadableStream<R>];
}

// @public (undocumented)
export interface ReadableStreamAsyncIterator<R> extends AsyncIterator<R> {
    // (undocumented)
    next(): Promise<IteratorResult<R>>;
    // (undocumented)
    return(value?: any): Promise<IteratorResult<any>>;
}

// @public (undocumented)
export type ReadableStreamBYOBReader = ReadableStreamBYOBReader_2;

// Warning: (ae-forgotten-export) The symbol "ReadableStreamBYOBRequest" needs to be exported by the entry point polyfill.d.ts
//
// @public (undocumented)
export type ReadableStreamBYOBRequest = ReadableStreamBYOBRequest_2;

// Warning: (ae-forgotten-export) The symbol "ReadableStreamDefaultController" needs to be exported by the entry point polyfill.d.ts
//
// @public (undocumented)
export type ReadableStreamDefaultController<R> = ReadableStreamDefaultController_2<R>;

// @public (undocumented)
export type ReadableStreamDefaultReader<R> = ReadableStreamDefaultReader_2<R>;

// @public (undocumented)
export type ReadResult<T> = {
    done: false;
    value: T;
} | {
    done: true;
    value?: T;
};

// @public (undocumented)
export interface Transformer<I = any, O = any> {
    // (undocumented)
    flush?: TransformStreamDefaultControllerCallback<O>;
    // (undocumented)
    readableType?: undefined;
    // Warning: (ae-forgotten-export) The symbol "TransformStreamDefaultControllerCallback" needs to be exported by the entry point polyfill.d.ts
    //
    // (undocumented)
    start?: TransformStreamDefaultControllerCallback<O>;
    // Warning: (ae-forgotten-export) The symbol "TransformStreamDefaultControllerTransformCallback" needs to be exported by the entry point polyfill.d.ts
    //
    // (undocumented)
    transform?: TransformStreamDefaultControllerTransformCallback<I, O>;
    // (undocumented)
    writableType?: undefined;
}

// @public (undocumented)
export class TransformStream<I = any, O = any> {
    constructor(transformer?: Transformer<I, O>, writableStrategy?: QueuingStrategy<I>, readableStrategy?: QueuingStrategy<O>);
    // (undocumented)
    get readable(): ReadableStream<O>;
    // (undocumented)
    get writable(): WritableStream<I>;
}

// Warning: (ae-forgotten-export) The symbol "TransformStreamDefaultController" needs to be exported by the entry point polyfill.d.ts
//
// @public (undocumented)
export type TransformStreamDefaultController<O> = TransformStreamDefaultController_2<O>;

// @public (undocumented)
export interface UnderlyingByteSource {
    // (undocumented)
    autoAllocateChunkSize?: number;
    // Warning: (ae-forgotten-export) The symbol "ReadableStreamErrorCallback" needs to be exported by the entry point polyfill.d.ts
    //
    // (undocumented)
    cancel?: ReadableStreamErrorCallback;
    // (undocumented)
    pull?: ReadableByteStreamControllerCallback;
    // Warning: (ae-forgotten-export) The symbol "ReadableByteStreamControllerCallback" needs to be exported by the entry point polyfill.d.ts
    //
    // (undocumented)
    start?: ReadableByteStreamControllerCallback;
    // (undocumented)
    type: 'bytes';
}

// @public (undocumented)
export interface UnderlyingSink<W = any> {
    // Warning: (ae-forgotten-export) The symbol "WritableStreamErrorCallback" needs to be exported by the entry point polyfill.d.ts
    //
    // (undocumented)
    abort?: WritableStreamErrorCallback;
    // Warning: (ae-forgotten-export) The symbol "WritableStreamDefaultControllerCloseCallback" needs to be exported by the entry point polyfill.d.ts
    //
    // (undocumented)
    close?: WritableStreamDefaultControllerCloseCallback;
    // Warning: (ae-forgotten-export) The symbol "WritableStreamDefaultControllerStartCallback" needs to be exported by the entry point polyfill.d.ts
    //
    // (undocumented)
    start?: WritableStreamDefaultControllerStartCallback;
    // (undocumented)
    type?: undefined;
    // Warning: (ae-forgotten-export) The symbol "WritableStreamDefaultControllerWriteCallback" needs to be exported by the entry point polyfill.d.ts
    //
    // (undocumented)
    write?: WritableStreamDefaultControllerWriteCallback<W>;
}

// @public (undocumented)
export interface UnderlyingSource<R = any> {
    // (undocumented)
    cancel?: ReadableStreamErrorCallback;
    // (undocumented)
    pull?: ReadableStreamDefaultControllerCallback<R>;
    // Warning: (ae-forgotten-export) The symbol "ReadableStreamDefaultControllerCallback" needs to be exported by the entry point polyfill.d.ts
    //
    // (undocumented)
    start?: ReadableStreamDefaultControllerCallback<R>;
    // (undocumented)
    type?: undefined;
}

// @public (undocumented)
export class WritableStream<W = any> {
    constructor(underlyingSink?: UnderlyingSink<W>, strategy?: QueuingStrategy<W>);
    // (undocumented)
    abort(reason: any): Promise<void>;
    // (undocumented)
    close(): Promise<void>;
    // Warning: (ae-forgotten-export) The symbol "WritableStreamDefaultWriter" needs to be exported by the entry point polyfill.d.ts
    //
    // (undocumented)
    getWriter(): WritableStreamDefaultWriter_2<W>;
    // (undocumented)
    get locked(): boolean;
}

// Warning: (ae-forgotten-export) The symbol "WritableStreamDefaultController" needs to be exported by the entry point polyfill.d.ts
//
// @public (undocumented)
export type WritableStreamDefaultController = WritableStreamDefaultController_2<any>;

// @public (undocumented)
export type WritableStreamDefaultWriter<W> = WritableStreamDefaultWriter_2<W>;


// (No @packageDocumentation comment for this package)

```
